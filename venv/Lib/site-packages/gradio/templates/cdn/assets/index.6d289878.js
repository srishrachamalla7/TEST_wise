import{S as B,i as C,s as R,d as f,v as O,y as T,Y as y,P as Q,Q as U,ak as k,ab as E,Z as D,h as I,b,c as j,e as N,f as Y,_ as q,$ as A,a0 as F,D as m,E as d,g as G,q as Z,G as z,H as J,B as L,C as V,F as W,K as X}from"./index.b0283b9c.js";import{a as P}from"./Tabs.d18fc9cb.js";const S="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/tabs/src/TabItem.svelte";function p(s){let e,a,t;const r=s[6].default,o=D(r,s,s[5],null),n={c:function(){e=I("div"),a=I("div"),o&&o.c(),b(a,"class","flex flex-col gr-gap gr-form-gap relative col overflow-auto flex-1"),j(a,S,19,2,600),b(e,"id",s[0]),b(e,"class","tabitem p-2 border-2 border-t-0 border-gray-200 relative flex"),j(e,S,15,1,503)},m:function(l,c){N(l,e,c),Y(e,a),o&&o.m(a,null),t=!0},p:function(l,c){o&&o.p&&(!t||c&32)&&q(o,r,l,l[5],t?F(r,l[5],c,null):A(l[5]),null),(!t||c&1)&&b(e,"id",l[0])},i:function(l){t||(m(o,l),t=!0)},o:function(l){d(o,l),t=!1},d:function(l){l&&G(e),o&&o.d(l)}};return f("SvelteRegisterBlock",{block:n,id:p.name,type:"if",source:"(15:0) {#if $selected_tab === id}",ctx:s}),n}function h(s){let e,a,t=s[1]===s[2]&&p(s);const r={c:function(){t&&t.c(),e=Z()},l:function(n){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(n,i){t&&t.m(n,i),N(n,e,i),a=!0},p:function(n,[i]){n[1]===n[2]?t?(t.p(n,i),i&2&&m(t,1)):(t=p(n),t.c(),m(t,1),t.m(e.parentNode,e)):t&&(z(),d(t,1,1,()=>{t=null}),J())},i:function(n){a||(m(t),a=!0)},o:function(n){d(t),a=!1},d:function(n){t&&t.d(n),n&&G(e)}};return f("SvelteRegisterBlock",{block:r,id:h.name,type:"component",source:"",ctx:s}),r}function x(s,e,a){let t,{$$slots:r={},$$scope:o}=e;O("TabItem",r,["default"]);let{elem_id:n=""}=e,{name:i}=e;const l=T(),c={},{register_tab:g,unregister_tab:v,selected_tab:_}=y(P);Q(_,"selected_tab"),U(s,_,u=>a(1,t=u)),g({name:i,id:c}),k(()=>()=>v({name:i,id:c}));const M=["elem_id","name"];return Object.keys(e).forEach(u=>{!~M.indexOf(u)&&u.slice(0,2)!=="$$"&&u!=="slot"&&console.warn(`<TabItem> was created with unknown prop '${u}'`)}),s.$$set=u=>{"elem_id"in u&&a(0,n=u.elem_id),"name"in u&&a(4,i=u.name),"$$scope"in u&&a(5,o=u.$$scope)},s.$capture_state=()=>({getContext:y,onMount:k,createEventDispatcher:T,tick:E,TABS:P,elem_id:n,name:i,dispatch:l,id:c,register_tab:g,unregister_tab:v,selected_tab:_,$selected_tab:t}),s.$inject_state=u=>{"elem_id"in u&&a(0,n=u.elem_id),"name"in u&&a(4,i=u.name)},e&&"$$inject"in e&&s.$inject_state(e.$$inject),s.$$.update=()=>{s.$$.dirty&2&&t===c&&E().then(()=>l("select"))},[n,t,c,_,i,o,r]}class H extends B{constructor(e){super(e),C(this,e,x,h,R,{elem_id:0,name:4}),f("SvelteRegisterComponent",{component:this,tagName:"TabItem",options:e,id:h.name});const{ctx:a}=this.$$,t=e.props||{};a[4]===void 0&&!("name"in t)&&console.warn("<TabItem> was created without expected prop 'name'")}get elem_id(){throw new Error("<TabItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<TabItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get name(){throw new Error("<TabItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set name(e){throw new Error("<TabItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function K(s){let e;const a=s[2].default,t=D(a,s,s[4],null),r={c:function(){t&&t.c()},m:function(n,i){t&&t.m(n,i),e=!0},p:function(n,i){t&&t.p&&(!e||i&16)&&q(t,a,n,n[4],e?F(a,n[4],i,null):A(n[4]),null)},i:function(n){e||(m(t,n),e=!0)},o:function(n){d(t,n),e=!1},d:function(n){t&&t.d(n)}};return f("SvelteRegisterBlock",{block:r,id:K.name,type:"slot",source:"(6:0) <TabItem {elem_id} name={label} on:select>",ctx:s}),r}function w(s){let e,a;e=new H({props:{elem_id:s[0],name:s[1],$$slots:{default:[K]},$$scope:{ctx:s}},$$inline:!0}),e.$on("select",s[3]);const t={c:function(){L(e.$$.fragment)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,n){V(e,o,n),a=!0},p:function(o,[n]){const i={};n&1&&(i.elem_id=o[0]),n&2&&(i.name=o[1]),n&16&&(i.$$scope={dirty:n,ctx:o}),e.$set(i)},i:function(o){a||(m(e.$$.fragment,o),a=!0)},o:function(o){d(e.$$.fragment,o),a=!1},d:function(o){W(e,o)}};return f("SvelteRegisterBlock",{block:t,id:w.name,type:"component",source:"",ctx:s}),t}function $(s,e,a){let{$$slots:t={},$$scope:r}=e;O("Tabs",t,["default"]);let{elem_id:o=""}=e,{label:n}=e;const i=["elem_id","label"];Object.keys(e).forEach(c=>{!~i.indexOf(c)&&c.slice(0,2)!=="$$"&&c!=="slot"&&console.warn(`<Tabs> was created with unknown prop '${c}'`)});function l(c){X.call(this,s,c)}return s.$$set=c=>{"elem_id"in c&&a(0,o=c.elem_id),"label"in c&&a(1,n=c.label),"$$scope"in c&&a(4,r=c.$$scope)},s.$capture_state=()=>({TabItem:H,elem_id:o,label:n}),s.$inject_state=c=>{"elem_id"in c&&a(0,o=c.elem_id),"label"in c&&a(1,n=c.label)},e&&"$$inject"in e&&s.$inject_state(e.$$inject),[o,n,t,l,r]}class ee extends B{constructor(e){super(e),C(this,e,$,w,R,{elem_id:0,label:1}),f("SvelteRegisterComponent",{component:this,tagName:"Tabs",options:e,id:w.name});const{ctx:a}=this.$$,t=e.props||{};a[1]===void 0&&!("label"in t)&&console.warn("<Tabs> was created without expected prop 'label'")}get elem_id(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var oe=ee;const se=["static"];export{oe as Component,se as modes};
