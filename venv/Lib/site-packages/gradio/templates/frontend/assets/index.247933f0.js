import{S as b,i as y,s as p,d,Z as R,v as B,h as O,b as h,c as D,e as E,l as N,_ as q,$ as F,a0 as K,D as P,E as k,g as j,K as z,P as Q,X as _,Q as U,B as X,C as Z,F as A,k as G,m as H}from"./index.66004ba3.js";import{c as w}from"./styles.d87a390f.js";const I="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/button/src/Button.svelte";function v(n){let e,t,a,u,s;const c=n[5].default,i=R(c,n,n[4],null),f={c:function(){e=O("button"),i&&i.c(),h(e,"class",t=`gr-button gr-button-${n[3]} gr-button-${n[2]} self-start`+w(n[0])),h(e,"id",n[1]),D(e,I,7,0,181)},l:function(l){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(l,o){E(l,e,o),i&&i.m(e,null),a=!0,u||(s=N(e,"click",n[6],!1,!1,!1),u=!0)},p:function(l,[o]){i&&i.p&&(!a||o&16)&&q(i,c,l,l[4],a?K(c,l[4],o,null):F(l[4]),null),(!a||o&13&&t!==(t=`gr-button gr-button-${l[3]} gr-button-${l[2]} self-start`+w(l[0])))&&h(e,"class",t),(!a||o&2)&&h(e,"id",l[1])},i:function(l){a||(P(i,l),a=!0)},o:function(l){k(i,l),a=!1},d:function(l){l&&j(e),i&&i.d(l),u=!1,s()}};return d("SvelteRegisterBlock",{block:f,id:v.name,type:"component",source:"",ctx:n}),f}function J(n,e,t){let{$$slots:a={},$$scope:u}=e;B("Button",a,["default"]);let{style:s={}}=e,{elem_id:c=""}=e,{variant:i="secondary"}=e,{size:f="lg"}=e;const m=["style","elem_id","variant","size"];Object.keys(e).forEach(o=>{!~m.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Button> was created with unknown prop '${o}'`)});function l(o){z.call(this,n,o)}return n.$$set=o=>{"style"in o&&t(0,s=o.style),"elem_id"in o&&t(1,c=o.elem_id),"variant"in o&&t(2,i=o.variant),"size"in o&&t(3,f=o.size),"$$scope"in o&&t(4,u=o.$$scope)},n.$capture_state=()=>({create_classes:w,style:s,elem_id:c,variant:i,size:f}),n.$inject_state=o=>{"style"in o&&t(0,s=o.style),"elem_id"in o&&t(1,c=o.elem_id),"variant"in o&&t(2,i=o.variant),"size"in o&&t(3,f=o.size)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[s,c,i,f,u,a,l]}class S extends b{constructor(e){super(e),y(this,e,J,v,p,{style:0,elem_id:1,variant:2,size:3}),d("SvelteRegisterComponent",{component:this,tagName:"Button",options:e,id:v.name})}get style(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get variant(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set variant(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get size(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set size(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function C(n){let e=n[4](n[2])+"",t;const a={c:function(){t=G(e)},m:function(s,c){E(s,t,c)},p:function(s,c){c&20&&e!==(e=s[4](s[2])+"")&&H(t,e)},d:function(s){s&&j(t)}};return d("SvelteRegisterBlock",{block:a,id:C.name,type:"slot",source:"(9:0) <Button {variant} {elem_id} {style} on:click>",ctx:n}),a}function g(n){let e,t;e=new S({props:{variant:n[3],elem_id:n[1],style:n[0],$$slots:{default:[C]},$$scope:{ctx:n}},$$inline:!0}),e.$on("click",n[5]);const a={c:function(){X(e.$$.fragment)},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,c){Z(e,s,c),t=!0},p:function(s,[c]){const i={};c&8&&(i.variant=s[3]),c&2&&(i.elem_id=s[1]),c&1&&(i.style=s[0]),c&84&&(i.$$scope={dirty:c,ctx:s}),e.$set(i)},i:function(s){t||(P(e.$$.fragment,s),t=!0)},o:function(s){k(e.$$.fragment,s),t=!1},d:function(s){A(e,s)}};return d("SvelteRegisterBlock",{block:a,id:g.name,type:"component",source:"",ctx:n}),a}function L(n,e,t){let a;Q(_,"_"),U(n,_,r=>t(4,a=r));let{$$slots:u={},$$scope:s}=e;B("Button",u,[]);let{style:c={}}=e,{elem_id:i=""}=e,{value:f}=e,{variant:m="primary"}=e;const l=["style","elem_id","value","variant"];Object.keys(e).forEach(r=>{!~l.indexOf(r)&&r.slice(0,2)!=="$$"&&r!=="slot"&&console.warn(`<Button> was created with unknown prop '${r}'`)});function o(r){z.call(this,n,r)}return n.$$set=r=>{"style"in r&&t(0,c=r.style),"elem_id"in r&&t(1,i=r.elem_id),"value"in r&&t(2,f=r.value),"variant"in r&&t(3,m=r.variant)},n.$capture_state=()=>({Button:S,_,style:c,elem_id:i,value:f,variant:m,$_:a}),n.$inject_state=r=>{"style"in r&&t(0,c=r.style),"elem_id"in r&&t(1,i=r.elem_id),"value"in r&&t(2,f=r.value),"variant"in r&&t(3,m=r.variant)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[c,i,f,m,a,o]}class M extends b{constructor(e){super(e),y(this,e,L,g,p,{style:0,elem_id:1,value:2,variant:3}),d("SvelteRegisterComponent",{component:this,tagName:"Button_1",options:e,id:g.name});const{ctx:t}=this.$$,a=e.props||{};t[2]===void 0&&!("value"in a)&&console.warn("<Button> was created without expected prop 'value'")}get style(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get variant(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set variant(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var W=M;const Y=["static"];export{W as Component,Y as modes};
