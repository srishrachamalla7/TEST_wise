import{S as V,i as z,s as A,d as p,o as x,v as G,y as D,a6 as H,a7 as N,a8 as k,h as b,k as q,w as B,b as h,c as C,e as g,f as v,m as F,g as w,n as I,u as W,I as X,R as J,T as Y,B as E,C as P,D as j,E as S,F as R,K as Z,U as $,V as ee}from"./index.66004ba3.js";import{B as L}from"./Block.65486579.js";import"./styles.d87a390f.js";const y="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/chatbot/src/ChatBot.svelte";function K(a,e,t){const s=a.slice();return s[8]=e[t],s}function O(a){let e,t=a[8][0]+"",s,i,d,n,c=a[8][1]+"",l,o,m;const u={c:function(){e=b("div"),s=q(t),d=B(),n=b("div"),l=q(c),o=B(),h(e,"data-testid","user"),h(e,"class","px-3 py-2 rounded-[22px] rounded-br-none text-white ml-7 text-sm"),h(e,"style",i="background-color:"+a[2][0]),C(e,y,37,3,968),h(n,"data-testid","bot"),h(n,"class","px-3 py-2 rounded-[22px] rounded-bl-none place-self-start text-white ml-7 text-sm"),h(n,"style",m="background-color:"+a[2][1]),C(n,y,44,3,1153)},m:function(f,r){g(f,e,r),v(e,s),g(f,d,r),g(f,n,r),v(n,l),v(n,o)},p:function(f,r){r&1&&t!==(t=f[8][0]+"")&&F(s,t),r&4&&i!==(i="background-color:"+f[2][0])&&h(e,"style",i),r&1&&c!==(c=f[8][1]+"")&&F(l,c),r&4&&m!==(m="background-color:"+f[2][1])&&h(n,"style",m)},d:function(f){f&&w(e),f&&w(d),f&&w(n)}};return p("SvelteRegisterBlock",{block:u,id:O.name,type:"each",source:"(37:2) {#each value as message}",ctx:a}),u}function T(a){let e,t,s=a[0];x(s);let i=[];for(let n=0;n<s.length;n+=1)i[n]=O(K(a,s,n));const d={c:function(){e=b("div"),t=b("div");for(let c=0;c<i.length;c+=1)i[c].c();h(t,"class","flex flex-col items-end space-y-4 p-3"),C(t,y,35,1,886),h(e,"class","overflow-y-auto h-[40vh]"),C(e,y,34,0,830)},l:function(c){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,l){g(c,e,l),v(e,t);for(let o=0;o<i.length;o+=1)i[o].m(t,null);a[4](e)},p:function(c,[l]){if(l&5){s=c[0],x(s);let o;for(o=0;o<s.length;o+=1){const m=K(c,s,o);i[o]?i[o].p(m,l):(i[o]=O(m),i[o].c(),i[o].m(t,null))}for(;o<i.length;o+=1)i[o].d(1);i.length=s.length}},i:I,o:I,d:function(c){c&&w(e),W(i,c),a[4](null)}};return p("SvelteRegisterBlock",{block:d,id:T.name,type:"component",source:"",ctx:a}),d}function te(a,e,t){let s,{$$slots:i={},$$scope:d}=e;G("ChatBot",i,[]);let{value:n}=e,{color_map:c=void 0}=e,l,o;const m=D();H(()=>{o=l&&l.offsetHeight+l.scrollTop>l.scrollHeight-20}),N(()=>{o&&l.scrollTo(0,l.scrollHeight)});function u(){return c?c.map(r=>r in k?k[r].primary:r):["#fb923c","#9ca3af"]}const _=["value","color_map"];Object.keys(e).forEach(r=>{!~_.indexOf(r)&&r.slice(0,2)!=="$$"&&r!=="slot"&&console.warn(`<ChatBot> was created with unknown prop '${r}'`)});function f(r){X[r?"unshift":"push"](()=>{l=r,t(1,l)})}return a.$$set=r=>{"value"in r&&t(0,n=r.value),"color_map"in r&&t(3,c=r.color_map)},a.$capture_state=()=>({beforeUpdate:H,afterUpdate:N,createEventDispatcher:D,colors:k,value:n,color_map:c,div:l,autoscroll:o,dispatch:m,get_colors:u,_colors:s}),a.$inject_state=r=>{"value"in r&&t(0,n=r.value),"color_map"in r&&t(3,c=r.color_map),"div"in r&&t(1,l=r.div),"autoscroll"in r&&(o=r.autoscroll),"_colors"in r&&t(2,s=r._colors)},e&&"$$inject"in e&&a.$inject_state(e.$$inject),a.$$.update=()=>{a.$$.dirty&1&&n&&m("change")},t(2,s=u()),[n,l,s,c,f]}class M extends V{constructor(e){super(e),z(this,e,te,T,A,{value:0,color_map:3}),p("SvelteRegisterComponent",{component:this,tagName:"ChatBot",options:e,id:T.name});const{ctx:t}=this.$$,s=e.props||{};t[0]===void 0&&!("value"in s)&&console.warn("<ChatBot> was created without expected prop 'value'")}get value(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get color_map(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set color_map(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function Q(a){let e,t,s,i;const d=[a[3]];let n={};for(let l=0;l<d.length;l+=1)n=Y(n,d[l]);e=new J({props:n,$$inline:!0}),s=new M({props:{value:a[1],color_map:a[2]},$$inline:!0}),s.$on("change",a[4]);const c={c:function(){E(e.$$.fragment),t=B(),E(s.$$.fragment)},m:function(o,m){P(e,o,m),g(o,t,m),P(s,o,m),i=!0},p:function(o,m){const u=m&8?$(d,[ee(o[3])]):{};e.$set(u);const _={};m&2&&(_.value=o[1]),m&4&&(_.color_map=o[2]),s.$set(_)},i:function(o){i||(j(e.$$.fragment,o),j(s.$$.fragment,o),i=!0)},o:function(o){S(e.$$.fragment,o),S(s.$$.fragment,o),i=!1},d:function(o){R(e,o),o&&w(t),R(s,o)}};return p("SvelteRegisterBlock",{block:c,id:Q.name,type:"slot",source:"(10:0) <Block padding={false} {elem_id}>",ctx:a}),c}function U(a){let e,t;e=new L({props:{padding:!1,elem_id:a[0],$$slots:{default:[Q]},$$scope:{ctx:a}},$$inline:!0});const s={c:function(){E(e.$$.fragment)},l:function(d){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(d,n){P(e,d,n),t=!0},p:function(d,[n]){const c={};n&1&&(c.elem_id=d[0]),n&46&&(c.$$scope={dirty:n,ctx:d}),e.$set(c)},i:function(d){t||(j(e.$$.fragment,d),t=!0)},o:function(d){S(e.$$.fragment,d),t=!1},d:function(d){R(e,d)}};return p("SvelteRegisterBlock",{block:s,id:U.name,type:"component",source:"",ctx:a}),s}function oe(a,e,t){let{$$slots:s={},$$scope:i}=e;G("Chatbot",s,[]);let{elem_id:d=""}=e,{value:n=[]}=e,{color_map:c}=e,{loading_status:l}=e;const o=["elem_id","value","color_map","loading_status"];Object.keys(e).forEach(u=>{!~o.indexOf(u)&&u.slice(0,2)!=="$$"&&u!=="slot"&&console.warn(`<Chatbot> was created with unknown prop '${u}'`)});function m(u){Z.call(this,a,u)}return a.$$set=u=>{"elem_id"in u&&t(0,d=u.elem_id),"value"in u&&t(1,n=u.value),"color_map"in u&&t(2,c=u.color_map),"loading_status"in u&&t(3,l=u.loading_status)},a.$capture_state=()=>({ChatBot:M,Block:L,StatusTracker:J,elem_id:d,value:n,color_map:c,loading_status:l}),a.$inject_state=u=>{"elem_id"in u&&t(0,d=u.elem_id),"value"in u&&t(1,n=u.value),"color_map"in u&&t(2,c=u.color_map),"loading_status"in u&&t(3,l=u.loading_status)},e&&"$$inject"in e&&a.$inject_state(e.$$inject),[d,n,c,l,m]}class ne extends V{constructor(e){super(e),z(this,e,oe,U,A,{elem_id:0,value:1,color_map:2,loading_status:3}),p("SvelteRegisterComponent",{component:this,tagName:"Chatbot",options:e,id:U.name});const{ctx:t}=this.$$,s=e.props||{};t[2]===void 0&&!("color_map"in s)&&console.warn("<Chatbot> was created without expected prop 'color_map'"),t[3]===void 0&&!("loading_status"in s)&&console.warn("<Chatbot> was created without expected prop 'loading_status'")}get elem_id(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get color_map(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set color_map(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var re=ne;const le=["static"];export{re as Component,le as modes};
